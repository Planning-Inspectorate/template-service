import { promisify } from 'node:util';
import * as msalNode from '@azure/msal-node';
import * as authSession from './session.service.ts';
import type { AuthService } from './auth-service.ts';
import type { RequestHandler } from 'express';
import type { Logger } from 'pino';

/**
 * Phase 1 – Navigate to external MSAL signin url
 *
 * Begin the MSAL OpenID Connect (OIDC) flow for an unauthenticated user by
 * forwarding them to the MSAL signin url. After signing in, the user will be
 * redirected by MSAL back to our application with an authentication code
 * generated by the signin process (see phase 2 below).
 */
export function buildStartMsalAuthentication(
	authService: AuthService
): RequestHandler<any, any, any, { redirect_to: string }> {
	return async (request, response) => {
		// A nonce is generated to identify the OIDC as originating from our
		// application, and for this OIDC attempt only. The nonce is later returned as
		// idTokenClaim within the authentication result fetched by the authentication
		// code, whereupon it is validated against the original nonce retained in the
		// session. Note that this is not susceptible to a downgrade attack like PKCE
		// because the verification is enforced locally and not in the auth server.
		const nonce = new msalNode.CryptoProvider().createNewGuid();
		// The url from which the OpenID Connect flow was triggered by the
		// application. Ultimately, we will forward the user to this route at the
		// end of the authentication journey.
		const postSigninRedirectUri = request.query.redirect_to || '/';

		// Set the data that will exist throughout the OpenID Connect flow lifecycle.
		// This will be consumed in phase 2 to verify the inbound redirect from the
		// MSAL authentication.
		authSession.setAuthenticationData(request.session, {
			nonce,
			postSigninRedirectUri
		});
		// Generate – and then redirect to – a url where the user will authenticate
		// against MSAL using their PINS account.
		response.redirect(await authService.getAuthCodeUrl({ nonce }, request.session.id));
	};
}

/**
 * Phase 2 – Handle redirect from MSAL signin url post-authentication
 *
 * Once the user has authenticated via MSAL, they are redirected back to the
 * application, where a `code` property generated by MSAL will be present in the
 * query params, and can be used to acquire an access token / account info. As
 * outlined in phase 1, we use the `nonce` stored in the session to validate the
 * request.
 *
 * Authentication is essentially complete when the `account` details from an
 * authentication result are assigned to the session.
 */
export function buildCompleteMsalAuthentication(
	logger: Logger,
	authService: AuthService
): RequestHandler<any, any, any, { code?: string }> {
	return async (request, response) => {
		if (request.query.code) {
			const { nonce, postSigninRedirectUri } = authSession.getAuthenticationData(request.session);

			const authenticationResult = await authService.acquireTokenByCode({
				code: request.query.code,
				sessionId: request.session.id
			});

			// After acquiring an authentication result from MSAL, verify that the
			// result is signed by the nonce for this authentication attempt. This check
			// prevents against replay attacks and CSRF attacks (note, that a CSRF
			// "attack" is still possible if an attacker wants to send a spoofed error
			// response directly to redirectUri as the nonce would not be in play, but
			// such a request has no nefarious effect on the application and would
			// basically be a waste of time).
			if (authenticationResult?.idTokenClaims?.nonce === nonce) {
				const regenerate = promisify(request.session.regenerate).bind(request.session);
				const save = promisify(request.session.save).bind(request.session);
				await regenerate();
				// store user information in session
				authSession.setAccount(request.session, authenticationResult);
				// save the session before redirection to ensure page
				// load does not happen before session is saved
				await save();
				response.redirect(postSigninRedirectUri);
			} else {
				logger.error({ nonce, authenticationResult }, 'Authentication failed. Nonce did not match.');
				response.redirect('/unauthenticated');
			}
		} else {
			// todo: determine what an actual MSAL error sent to this controller looks
			// like so it can be correctly fed into pino
			logger.error('Authentication failed – MSAL was unable to generate authentication code.');
			response.redirect('/unauthenticated');
		}
	};
}

/**
 * Destroy any data belonging to an authenticated user. This endpoint will be
 * invoked by MSAL after single sign-out occurs.
 */
export function buildHandleSignout(logger: Logger, logoutUri: string, authService: AuthService): RequestHandler {
	return async (req, response) => {
		const account = authSession.getAccount(req.session);

		if (account) {
			try {
				await authService.clearCacheForAccount(account, req.session.id);
			} catch (err) {
				logger.error(err, 'Failed to remove account from cache:');
			}
		}

		const sessionId = req.session.id;
		await promisify(req.session.destroy.bind(req.session))();

		logger.info({ sessionId }, 'clearing session:');

		response.setHeader('Clear-Site-Data', '*');
		response.clearCookie('connect.sid', { path: '/' }).redirect(logoutUri);
	};
}
